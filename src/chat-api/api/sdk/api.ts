/* tslint:disable */
/* eslint-disable */
/**
 * Chat API SDK
 * The SDK allows you to receive and send messages through your WhatsApp account. [Sign up now](https://app.chat-api.com/)  The Chat API is based on the WhatsApp WEB protocol and excludes the ban both when using libraries from mgp25 and the like. Despite this, your account can be banned by anti-spam system WhatsApp after several clicking the \"block\" button.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: sale@chat-sdk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Ack
 */
export interface Ack {
    /**
     * unique id
     * @type {string}
     * @memberof Ack
     */
    'id'?: string;
    /**
     * message id in queue
     * @type {number}
     * @memberof Ack
     */
    'queueNumber'?: number;
    /**
     * chat ID
     * @type {string}
     * @memberof Ack
     */
    'chatId'?: string;
    /**
     * type of the message status
     * @type {string}
     * @memberof Ack
     */
    'status'?: AckStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AckStatusEnum {
    Delivered = 'delivered',
    Viewed = 'viewed'
}

/**
 * 
 * @export
 * @interface BanSettings
 */
export interface BanSettings {
    /**
     * 
     * @type {string}
     * @memberof BanSettings
     */
    'banPhoneMask': string | null;
    /**
     * 
     * @type {string}
     * @memberof BanSettings
     */
    'preBanMessage': string | null;
    /**
     * Flag indicating that the current request has changed ban settings
     * @type {boolean}
     * @memberof BanSettings
     */
    'set': boolean;
}
/**
 * 
 * @export
 * @interface BanTestAction
 */
export interface BanTestAction {
    /**
     * A phone number starting with the country code. USA example: \"17472822486\".
     * @type {string}
     * @memberof BanTestAction
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface BanTestStatus
 */
export interface BanTestStatus {
    /**
     * 
     * @type {boolean}
     * @memberof BanTestStatus
     */
    'banned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BanTestStatus
     */
    'message'?: string;
    /**
     * Test phone number
     * @type {string}
     * @memberof BanTestStatus
     */
    'phone'?: string;
    /**
     * Test regex
     * @type {string}
     * @memberof BanTestStatus
     */
    'banPhoneMask'?: string;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * chat id
     * @type {string}
     * @memberof Chat
     */
    'id'?: string;
    /**
     * chat name
     * @type {string}
     * @memberof Chat
     */
    'name'?: string;
    /**
     * HTTPS link on avatar or group image
     * @type {string}
     * @memberof Chat
     */
    'image'?: string;
    /**
     * Additional info about chat
     * @type {object}
     * @memberof Chat
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ChatIdProp
 */
export interface ChatIdProp {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof ChatIdProp
     */
    'chatId'?: string;
}
/**
 * 
 * @export
 * @interface ChatUpdate
 */
export interface ChatUpdate {
    /**
     * 
     * @type {Chat}
     * @memberof ChatUpdate
     */
    'old'?: Chat;
    /**
     * 
     * @type {Chat}
     * @memberof ChatUpdate
     */
    'new'?: Chat;
}
/**
 * 
 * @export
 * @interface Chats
 */
export interface Chats {
    /**
     * 
     * @type {Array<Chat>}
     * @memberof Chats
     */
    'dialogs'?: Array<Chat>;
}
/**
 * 
 * @export
 * @interface ClearActionsQueueStatus
 */
export interface ClearActionsQueueStatus {
    /**
     * Actions queue clear status
     * @type {string}
     * @memberof ClearActionsQueueStatus
     */
    'message'?: string;
    /**
     * Type of the first hundred actions from the cleaned queue
     * @type {Array<string>}
     * @memberof ClearActionsQueueStatus
     */
    'actionsExample'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClearMessagesQueueStatus
 */
export interface ClearMessagesQueueStatus {
    /**
     * Messages queue clear status
     * @type {string}
     * @memberof ClearMessagesQueueStatus
     */
    'message'?: string;
    /**
     * Content of the first hundred messages from the cleaned queue
     * @type {Array<string>}
     * @memberof ClearMessagesQueueStatus
     */
    'messageTextsExample'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateGroupAction
 */
export interface CreateGroupAction {
    /**
     * Name of the group being created
     * @type {string}
     * @memberof CreateGroupAction
     */
    'groupName': string;
    /**
     * **Required if phones is not set**  An array of new participients chatIds. 
     * @type {Array<string>}
     * @memberof CreateGroupAction
     */
    'chatIds'?: Array<string>;
    /**
     * **Required if chatIds is not set**  An array of phones starting with the country code. You do not need to add your number.   USA example: [17472822486\'].
     * @type {Array<number>}
     * @memberof CreateGroupAction
     */
    'phones'?: Array<number>;
    /**
     * The text of the message that will be sent to the group when it is created. If you do not set a parameter, the message will not be sent
     * @type {string}
     * @memberof CreateGroupAction
     */
    'messageText'?: string;
}
/**
 * 
 * @export
 * @interface CreateGroupStatus
 */
export interface CreateGroupStatus {
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupStatus
     */
    'created'?: boolean;
    /**
     * Group creation status
     * @type {string}
     * @memberof CreateGroupStatus
     */
    'message'?: string;
    /**
     * Created group id
     * @type {string}
     * @memberof CreateGroupStatus
     */
    'chatId'?: string;
    /**
     * Link invitation to the group
     * @type {string}
     * @memberof CreateGroupStatus
     */
    'groupInviteLink'?: string;
}
/**
 * 
 * @export
 * @interface ForwardMessageRequest
 */
export interface ForwardMessageRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof ForwardMessageRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof ForwardMessageRequest
     */
    'phone'?: number;
    /**
     * Message ID | Message IDs array. Example: \"false_6590996758@c.us_3EB03104D2B84CEAD82F\" or [\"false_6590996758@c.us_3EB03104D2B84CEAD82F\", \"false_6590996758@c.us_3EB03104D2B84CEAD82G\"]
     * @type {string}
     * @memberof ForwardMessageRequest
     */
    'messageId': string;
}
/**
 * 
 * @export
 * @interface GroupParticipantAction
 */
export interface GroupParticipantAction {
    /**
     * Chat ID from the chat list. Examples: 19680561234-1479621234@g.us for the group.
     * @type {string}
     * @memberof GroupParticipantAction
     */
    'groupId': string;
    /**
     * **Required if participantPhone is not set**  Chat ID from the message list. Examples: 17633123456@c.us. Used instead of the participantPhone parameter.
     * @type {string}
     * @memberof GroupParticipantAction
     */
    'participantChatId': string;
    /**
     * **Required if participantChatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof GroupParticipantAction
     */
    'participantPhone'?: number;
}
/**
 * 
 * @export
 * @interface GroupParticipantStatus
 */
export interface GroupParticipantStatus {
    /**
     * 
     * @type {boolean}
     * @memberof GroupParticipantStatus
     */
    'add'?: boolean;
    /**
     * Status of adding participant to group
     * @type {string}
     * @memberof GroupParticipantStatus
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantStatus
     */
    'groupId'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Instance Status
     * @type {string}
     * @memberof InlineResponse200
     */
    'accountStatus'?: InlineResponse200AccountStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200AccountStatusEnum {
    LogoutRequestSentToWhatsApp = 'Logout request sent to WhatsApp'
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Instance Status
     * @type {string}
     * @memberof InlineResponse2001
     */
    'accountStatus'?: InlineResponse2001AccountStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001AccountStatusEnum {
    SentToWhatsApp = 'Takeover request sent to WhatsApp',
    NotSentBecauseReasonDontEqualsConflict = 'Takeover request not sent because reason don\'t equals \"conflict\"'
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Instance Status
     * @type {string}
     * @memberof InlineResponse2002
     */
    'accountStatus'?: InlineResponse2002AccountStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002AccountStatusEnum {
    SentToWhatsApp = 'Expiry request sent to WhatsApp',
    NotSentBecauseSubstatusDontEqualsExpired = 'Expiry request not sent because substatus don\'t equals \"expired\"'
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * Instance Status
     * @type {string}
     * @memberof InlineResponse2003
     */
    'accountStatus'?: InlineResponse2003AccountStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003AccountStatusEnum {
    SentToWhatsApp = 'Retry request sent to WhatsApp',
    NotSentBecauseReasonDontEqualsSyncing = 'Retry request not sent because reason don\'t equals \"syncing\"'
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    'webhookUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'ackNotificationsOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'chatUpdateOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'videoUploadOn'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    'proxy'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'guaranteedHooks'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'ignoreOldMessages'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'processArchive'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'instanceStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'webhookStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    'statusNotificationsOn'?: boolean | null;
    /**
     *
     * @type {number}
     * @memberof Settings
     */
    'sendDelay'?: number | null;
    /**
     *
     * @type {boolean}
     * @memberof Settings
     */
    'disableDialogsArchive'?: boolean | null;
    /**
     *
     * @type {boolean}
     * @memberof Settings
     */
    'parallelHooks'?: boolean | null;
    /**
     * 
     * @type {InlineResponse2005Update}
     * @memberof InlineResponse2005
     */
    'update': InlineResponse2005Update;
}
/**
 * An object that lists the fields changed in the request
 * @export
 * @interface InlineResponse2005Update
 */
export interface InlineResponse2005Update {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Update
     */
    'webhookUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'ackNotificationsOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'chatUpdateOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'videoUploadOn'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Update
     */
    'proxy'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'guaranteedHooks'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'ignoreOldMessages'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'processArchive'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'instanceStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'webhookStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Update
     */
    'statusNotificationsOn'?: boolean | null;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface InstanceStatus
 */
export interface InstanceStatus {
    /**
     * Instance Status
     * @type {string}
     * @memberof InstanceStatus
     */
    'accountStatus'?: InstanceStatusAccountStatusEnum;
    /**
     * Base64-encoded contents of the QR code
     * @type {string}
     * @memberof InstanceStatus
     */
    'qrCode'?: string;
    /**
     * 
     * @type {InstanceStatusStatusData}
     * @memberof InstanceStatus
     */
    'statusData'?: InstanceStatusStatusData;
}

/**
    * @export
    * @enum {string}
    */
export enum InstanceStatusAccountStatusEnum {
    GotQrCode = 'got qr code',
    Authenticated = 'authenticated',
    Loading = 'loading',
    Init = 'init',
    NotPaid = 'not_paid'
}

/**
 * Action for change status
 * @export
 * @interface InstanceStatusAction
 */
export interface InstanceStatusAction {
    /**
     * Method name
     * @type {string}
     * @memberof InstanceStatusAction
     */
    'act'?: InstanceStatusActionActEnum;
    /**
     * Action caption for the button
     * @type {string}
     * @memberof InstanceStatusAction
     */
    'label'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InstanceStatusActionActEnum {
    Expiry = 'expiry',
    Retry = 'retry',
    Takeover = 'takeover',
    Logout = 'logout'
}

/**
 * Status information link
 * @export
 * @interface InstanceStatusLink
 */
export interface InstanceStatusLink {
    /**
     * Link caption for the button
     * @type {string}
     * @memberof InstanceStatusLink
     */
    'label'?: string;
    /**
     * Reference URL instead of method
     * @type {string}
     * @memberof InstanceStatusLink
     */
    'link'?: string;
}
/**
 * More information about instance status
 * @export
 * @interface InstanceStatusStatusData
 */
export interface InstanceStatusStatusData {
    /**
     * Instance Substatus
     * @type {string}
     * @memberof InstanceStatusStatusData
     */
    'substatus'?: InstanceStatusStatusDataSubstatusEnum;
    /**
     * Status title in the language of the instance
     * @type {string}
     * @memberof InstanceStatusStatusData
     */
    'title'?: string;
    /**
     * Status message in the language of the instance
     * @type {string}
     * @memberof InstanceStatusStatusData
     */
    'msg'?: string;
    /**
     * Additional status message in the language of the instance
     * @type {string}
     * @memberof InstanceStatusStatusData
     */
    'submsg'?: string;
    /**
     * 
     * @type {InstanceStatusStatusDataActions}
     * @memberof InstanceStatusStatusData
     */
    'actions'?: InstanceStatusStatusDataActions;
    /**
     * The reason why the instance is in \"loading\" status
     * @type {string}
     * @memberof InstanceStatusStatusData
     */
    'reason'?: InstanceStatusStatusDataReasonEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InstanceStatusStatusDataSubstatusEnum {
    Normal = 'normal',
    Loading = 'loading',
    Offline = 'offline',
    Expired = 'expired',
    Opening = 'opening',
    Pairing = 'pairing',
    Timeout = 'timeout',
    Computer = 'computer',
    Phone = 'phone',
    BatteryLow1 = 'battery_low_1',
    BatteryLow2 = 'battery_low_2'
}
/**
    * @export
    * @enum {string}
    */
export enum InstanceStatusStatusDataReasonEnum {
    Connecting = 'connecting',
    Syncing = 'syncing',
    Offline = 'offline',
    Proxyblock = 'proxyblock',
    Conflict = 'conflict'
}

/**
 * Actions that can be applied to change the status
 * @export
 * @interface InstanceStatusStatusDataActions
 */
export interface InstanceStatusStatusDataActions {
    /**
     * 
     * @type {InstanceStatusAction}
     * @memberof InstanceStatusStatusDataActions
     */
    'expiry'?: InstanceStatusAction;
    /**
     * 
     * @type {InstanceStatusAction}
     * @memberof InstanceStatusStatusDataActions
     */
    'retry'?: InstanceStatusAction;
    /**
     * 
     * @type {InstanceStatusAction}
     * @memberof InstanceStatusStatusDataActions
     */
    'logout'?: InstanceStatusAction;
    /**
     * 
     * @type {InstanceStatusAction}
     * @memberof InstanceStatusStatusDataActions
     */
    'takeover'?: InstanceStatusAction;
    /**
     * 
     * @type {InstanceStatusLink}
     * @memberof InstanceStatusStatusDataActions
     */
    'learn_more'?: InstanceStatusLink;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * unique id
     * @type {string}
     * @memberof Message
     */
    'id'?: string;
    /**
     * text message for type \"chat\", or link to download the file for \"ptt\", \"image\", \"audio\", \"video\" and \"document\", or latitude and longitude for \"location\", or message \"[Call]\" for \"call_log\"
     * @type {string}
     * @memberof Message
     */
    'body'?: string;
    /**
     * type of the message
     * @type {string}
     * @memberof Message
     */
    'type'?: MessageTypeEnum;
    /**
     * Sender name
     * @type {string}
     * @memberof Message
     */
    'senderName'?: string;
    /**
     * true - outgoing, false - incoming
     * @type {boolean}
     * @memberof Message
     */
    'fromMe'?: boolean;
    /**
     * Author ID of the message, useful for groups
     * @type {string}
     * @memberof Message
     */
    'author'?: string;
    /**
     * send time, unix timestamp
     * @type {number}
     * @memberof Message
     */
    'time'?: number;
    /**
     * chat ID
     * @type {string}
     * @memberof Message
     */
    'chatId'?: string;
    /**
     * sequence number of the message in the database
     * @type {number}
     * @memberof Message
     */
    'messageNumber'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageTypeEnum {
    Chat = 'chat',
    Image = 'image',
    Ptt = 'ptt',
    Document = 'document',
    Audio = 'audio',
    Video = 'video',
    Location = 'location',
    CallLog = 'call_log'
}

/**
 * 
 * @export
 * @interface Messages
 */
export interface Messages {
    /**
     * 
     * @type {Array<Message>}
     * @memberof Messages
     */
    'messages'?: Array<Message>;
    /**
     * next query should be /messages?lastMessageNumber=199
     * @type {number}
     * @memberof Messages
     */
    'lastMessageNumber'?: number;
}
/**
 * 
 * @export
 * @interface OutboundAction
 */
export interface OutboundAction {
    /**
     * action id in queue
     * @type {number}
     * @memberof OutboundAction
     */
    'id'?: number;
    /**
     * type of the action in queue
     * @type {string}
     * @memberof OutboundAction
     */
    'type'?: OutboundActionTypeEnum;
    /**
     * Last try time to execute a action
     * @type {number}
     * @memberof OutboundAction
     */
    'last_try'?: number;
    /**
     * Additional action data
     * @type {object}
     * @memberof OutboundAction
     */
    'json_data'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum OutboundActionTypeEnum {
    CreateGroup = 'create group',
    AddGroupParticipant = 'add group participant',
    RemoveGroupParticipant = 'remove group participant',
    PromoteGroupParticipant = 'promote group participant',
    DemoteGroupParticipant = 'demote group participant',
    ReadChat = 'read chat'
}

/**
 * 
 * @export
 * @interface OutboundActions
 */
export interface OutboundActions {
    /**
     * Total number of actions in the queue
     * @type {number}
     * @memberof OutboundActions
     */
    'totalActions'?: number;
    /**
     * 
     * @type {Array<OutboundAction>}
     * @memberof OutboundActions
     */
    'first100'?: Array<OutboundAction>;
}
/**
 * 
 * @export
 * @interface OutboundMessage
 */
export interface OutboundMessage {
    /**
     * message id in queue
     * @type {number}
     * @memberof OutboundMessage
     */
    'id'?: number;
    /**
     * text message in queue
     * @type {string}
     * @memberof OutboundMessage
     */
    'body'?: string;
    /**
     * type of the message in queue
     * @type {string}
     * @memberof OutboundMessage
     */
    'type'?: OutboundMessageTypeEnum;
    /**
     * Last try time to send a message
     * @type {number}
     * @memberof OutboundMessage
     */
    'last_try'?: number;
    /**
     * Additional message data
     * @type {object}
     * @memberof OutboundMessage
     */
    'metadata'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum OutboundMessageTypeEnum {
    Chat = 'chat',
    Image = 'image',
    Ptt = 'ptt',
    Document = 'document',
    Audio = 'audio',
    Video = 'video',
    Location = 'location',
    CallLog = 'call_log'
}

/**
 * 
 * @export
 * @interface OutboundMessages
 */
export interface OutboundMessages {
    /**
     * Total number of messages in the queue
     * @type {number}
     * @memberof OutboundMessages
     */
    'totalMessages'?: number;
    /**
     * 
     * @type {Array<OutboundMessage>}
     * @memberof OutboundMessages
     */
    'first100'?: Array<OutboundMessage>;
}
/**
 * 
 * @export
 * @interface PhoneProp
 */
export interface PhoneProp {
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof PhoneProp
     */
    'phone'?: number;
}
/**
 * 
 * @export
 * @interface ReadChatAction
 */
export interface ReadChatAction {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof ReadChatAction
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {string}
     * @memberof ReadChatAction
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface ReadChatStatus
 */
export interface ReadChatStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ReadChatStatus
     */
    'read'?: boolean;
    /**
     * Chat reading status
     * @type {string}
     * @memberof ReadChatStatus
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReadChatStatus
     */
    'chatId'?: string;
}
/**
 * 
 * @export
 * @interface SendContactRequest
 */
export interface SendContactRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendContactRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendContactRequest
     */
    'phone'?: number;
    /**
     * Contact ID | Contact IDs array. Example: \"17633123456@c.us\" or [\"17633123456@c.us\", \"17633123457@c.us\"]
     * @type {string}
     * @memberof SendContactRequest
     */
    'contactId': string;
}
/**
 * 
 * @export
 * @interface SendFileRequest
 */
export interface SendFileRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendFileRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendFileRequest
     */
    'phone'?: number;
    /**
     * HTTP link *https://upload.wikimedia.org/wikipedia/ru/3/33/NatureCover2001.jpg*  Or base64-encoded file with mime data, for example *data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...*   File in form-data input field
     * @type {string}
     * @memberof SendFileRequest
     */
    'body': string;
    /**
     * File name, for *example 1.jpg* or *hello.xlsx*
     * @type {string}
     * @memberof SendFileRequest
     */
    'filename': string;
    /**
     * Text under the file
     * @type {string}
     * @memberof SendFileRequest
     */
    'caption'?: string;
    /**
     * Try to use a previously uploaded file instead of uploading it with each request
     * @type {boolean}
     * @memberof SendFileRequest
     */
    'cached'?: boolean;
    /**
     * Quoted message ID from the message list
     * @type {string}
     * @memberof SendFileRequest
     */
    'quotedMsgId'?: string;
}
/**
 * 
 * @export
 * @interface SendLinkRequest
 */
export interface SendLinkRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendLinkRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendLinkRequest
     */
    'phone'?: number;
    /**
     * HTTP or HTTPS link, for example *https://wikimedia.org*
     * @type {string}
     * @memberof SendLinkRequest
     */
    'body': string;
    /**
     * Base64-encoded file with mime data, for example *data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...* for link\'s preview
     * @type {string}
     * @memberof SendLinkRequest
     */
    'previewBase64': string;
    /**
     * Title for send link
     * @type {string}
     * @memberof SendLinkRequest
     */
    'title': string;
    /**
     * Description for send link
     * @type {string}
     * @memberof SendLinkRequest
     */
    'description'?: string;
    /**
     * Quoted message ID from the message list.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'quotedMsgId'?: string;
    /**
     * Phone numbers of the mentioned contacts in an array or in a comma-separated string.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'mentionedPhones'?: string;
    /**
     * Text containing the link.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SendLocationRequest
 */
export interface SendLocationRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendLocationRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendLocationRequest
     */
    'phone'?: number;
    /**
     * Latitude
     * @type {number}
     * @memberof SendLocationRequest
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof SendLocationRequest
     */
    'lng': number;
    /**
     * Text under the location.  Supports two lines. To use two lines, use the \"\\n\" symbol.
     * @type {string}
     * @memberof SendLocationRequest
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendMessageRequest
     */
    'phone'?: number;
    /**
     * Message text, UTF-8 or UTF-16 string with emoji 🍏
     * @type {string}
     * @memberof SendMessageRequest
     */
    'body': string;
    /**
     * Quoted message ID from the message list.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'quotedMsgId'?: string;
    /**
     * Phone numbers of the mentioned contacts in an array or in a comma-separated string.
     * @type {string}
     * @memberof SendMessageRequest
     */
    'mentionedPhones'?: string;
}
/**
 *
 * @export
 * @interface SendProductRequest
 */
export interface SendProductRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendProductRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendProductRequest
     */
    'phone'?: number;
    /**
     * HTTP link *https://upload.wikimedia.org/wikipedia/ru/3/33/NatureCover2001.jpg*  Or base64-encoded file with mime data, for example *data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...*   File in form-data input field
     * @type {string}
     * @memberof SendProductRequest
     */
    'body': string;
    /**
     * File name, for *example 1.jpg* or *hello.xlsx*
     * @type {string}
     * @memberof SendProductRequest
     */
    'filename': string;
    /**
     * **Id of the product. Can be achieved via /getProducts.
     * @type {string}
     * @memberof SendProductRequest
     */
    'productId': string;
}
/**
 *
 * @export
 * @interface SendButtonsRequest
 */
export interface SendButtonsRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendButtonsRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendButtonsRequest
     */
    'phone'?: number;
    /**
     * **Message title, displayed on top of the message. Example: Title.
     * @type {string}
     * @memberof SendButtonsRequest
     */
    'title': string;
    /**
     * **Text of message. Example: Please choose option.
     * @type {string}
     * @memberof SendButtonsRequest
     */
    'body': string;
    /**
     * **Message footer, displayed on bottom of the message. Example: Thank you.
     * @type {string}
     * @memberof SendButtonsRequest
     */
    'footer': string;
    /**
     * **Array of available buttons. Example: ["Option A", "Option B"]
     * @type {Array<string>}
     * @memberof SendButtonsRequest
     */
    'buttons': Array<string>
}
/**
 *
 * @export
 * @interface DeleteMessageRequest
 */
export interface DeleteMessageRequest {
    /**
     * **Message ID from messages history. Example: "false_6590996758@c.us_3EB03104D2B84CEAD82F".
     * @type {string}
     * @memberof SendProductRequest
     */
    'messageId': string;
}
/**
 * 
 * @export
 * @interface SendMessageStatus
 */
export interface SendMessageStatus {
    /**
     * 
     * @type {boolean}
     * @memberof SendMessageStatus
     */
    'sent'?: boolean;
    /**
     * unique message id
     * @type {string}
     * @memberof SendMessageStatus
     */
    'id'?: string;
    /**
     * Posting status message
     * @type {string}
     * @memberof SendMessageStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SendPTTRequest
 */
export interface SendPTTRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendPTTRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendPTTRequest
     */
    'phone'?: number;
    /**
     * A link to an audio ogg-file in opus codec  Or base64 ogg-file in opus codec, for example *data:audio/ogg;base64,...*
     * @type {string}
     * @memberof SendPTTRequest
     */
    'audio': string;
    /**
     * Quoted message ID from the message list
     * @type {string}
     * @memberof SendFileRequest
     */
    'quotedMsgId'?: string;
}
/**
 * 
 * @export
 * @interface SendVCardRequest
 */
export interface SendVCardRequest {
    /**
     * **Required if phone is not set**  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group. Used instead of the phone parameter.
     * @type {string}
     * @memberof SendVCardRequest
     */
    'chatId'?: string;
    /**
     * **Required if chatId is not set**  A phone number starting with the country code. You do not need to add your number.   USA example: 17472822486.
     * @type {number}
     * @memberof SendVCardRequest
     */
    'phone'?: number;
    /**
     * Text value vcard 3.0
     * @type {string}
     * @memberof SendVCardRequest
     */
    'vcard': string;
}
/**
 * 
 * @export
 * @interface SetWebhookStatus
 */
export interface SetWebhookStatus {
    /**
     * Flag indicating that the current request has changed webhook
     * @type {boolean}
     * @memberof SetWebhookStatus
     */
    'set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SetWebhookStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'webhookUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'ackNotificationsOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'chatUpdateOn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'videoUploadOn'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'proxy'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'guaranteedHooks'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'ignoreOldMessages'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'processArchive'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'instanceStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'webhookStatuses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Settings
     */
    'statusNotificationsOn'?: boolean | null;
    /**
     *
     * @type {number}
     * @memberof Settings
     */
    'sendDelay'?: number | null;
    /**
     *
     * @type {boolean}
     * @memberof Settings
     */
    'disableDialogsArchive'?: boolean | null;
    /**
     *
     * @type {boolean}
     * @memberof Settings
     */
    'parallelHooks'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * status date
     * @type {string}
     * @memberof Status
     */
    'date'?: string;
    /**
     * status name (\"init\", \"got qr code\", \"loading\", \"authenticated\")
     * @type {string}
     * @memberof Status
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Statuses
 */
export interface Statuses {
    /**
     * 
     * @type {Array<Status>}
     * @memberof Statuses
     */
    'data'?: Array<Status>;
}
/**
 * 
 * @export
 * @interface WebhookStatus
 */
export interface WebhookStatus {
    /**
     * message id
     * @type {string}
     * @memberof WebhookStatus
     */
    'msgId'?: string;
    /**
     * creation date
     * @type {string}
     * @memberof WebhookStatus
     */
    'time'?: string;
    /**
     * status name (\"sent\", \"not sent\", \"queued\")
     * @type {string}
     * @memberof WebhookStatus
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface WebhookUrl
 */
export interface WebhookUrl {
    /**
     * Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).
     * @type {string}
     * @memberof WebhookUrl
     */
    'webhookUrl': string;
}

/**
 * Class1InstanceApi - axios parameter creator
 * @export
 */
export const Class1InstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates the QR code after its expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expiry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Direct link to QR-code in the form of an image, not base64.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQRCode: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/qr_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reauthorization is necessary only in case of changing the device or manually pressing \"Logout on all devices\" on the phone. Keep the WhastsApp application open during authorization.  Instance statuses:  **authenticated** -  Authorization passed successfully  **init** -  Initial status   **loading** -  The system is still loading, try again in 1 minute   **got qr code** -  There is a QR code and you need to take a picture of it in the Whatsapp application by going to Menu -> WhatsApp Web -> Add. QR code is valid for one minute.   [Example showing base64 images on a page.](https://stackoverflow.com/questions/31526085/how-to-encode-an-image-into-an-html-file)  Manually easier to get [QR-code as an image](/#getQRCode)    When you request the status of the instance in standby mode (status **\"init\"**), it will automatically turn on. To avoid this behavior, use the **no_wakeup** parameter
         * @summary Get the account status and QR code for authorization.
         * @param {boolean} [full] Get full information on the current status
         * @param {boolean} [noWakeup] Ignore autowakeup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (full?: boolean, noWakeup?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (full !== undefined) {
                localVarQueryParameter['full'] = full;
            }

            if (noWakeup !== undefined) {
                localVarQueryParameter['no_wakeup'] = noWakeup;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout from WhatsApp Web to get new QR code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot your whatsapp instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reboot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reboot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Repeat the manual synchronization attempt with the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/retry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Set settings
         * @param {Settings} settings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSettings: async (settings: Settings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settings' is not null or undefined
            assertParamExists('setSettings', 'settings', settings)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the active session if the device has connected another instance of Web WhatsApp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeover: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/takeover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1InstanceApi - functional programming interface
 * @export
 */
export const Class1InstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1InstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates the QR code after its expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expiry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expiry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Direct link to QR-code in the form of an image, not base64.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQRCode(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQRCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Settings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reauthorization is necessary only in case of changing the device or manually pressing \"Logout on all devices\" on the phone. Keep the WhastsApp application open during authorization.  Instance statuses:  **authenticated** -  Authorization passed successfully  **init** -  Initial status   **loading** -  The system is still loading, try again in 1 minute   **got qr code** -  There is a QR code and you need to take a picture of it in the Whatsapp application by going to Menu -> WhatsApp Web -> Add. QR code is valid for one minute.   [Example showing base64 images on a page.](https://stackoverflow.com/questions/31526085/how-to-encode-an-image-into-an-html-file)  Manually easier to get [QR-code as an image](/#getQRCode)    When you request the status of the instance in standby mode (status **\"init\"**), it will automatically turn on. To avoid this behavior, use the **no_wakeup** parameter
         * @summary Get the account status and QR code for authorization.
         * @param {boolean} [full] Get full information on the current status
         * @param {boolean} [noWakeup] Ignore autowakeup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(full?: boolean, noWakeup?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(full, noWakeup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout from WhatsApp Web to get new QR code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot your whatsapp instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reboot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reboot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Repeat the manual synchronization attempt with the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Set settings
         * @param {Settings} settings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSettings(settings: Settings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSettings(settings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the active session if the device has connected another instance of Web WhatsApp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async takeover(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.takeover(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class1InstanceApi - factory interface
 * @export
 */
export const Class1InstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1InstanceApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates the QR code after its expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expiry(options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.expiry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Direct link to QR-code in the form of an image, not base64.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQRCode(options?: any): AxiosPromise<any> {
            return localVarFp.getQRCode(options).then((request) => request(axios, basePath));
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: any): AxiosPromise<Settings> {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Reauthorization is necessary only in case of changing the device or manually pressing \"Logout on all devices\" on the phone. Keep the WhastsApp application open during authorization.  Instance statuses:  **authenticated** -  Authorization passed successfully  **init** -  Initial status   **loading** -  The system is still loading, try again in 1 minute   **got qr code** -  There is a QR code and you need to take a picture of it in the Whatsapp application by going to Menu -> WhatsApp Web -> Add. QR code is valid for one minute.   [Example showing base64 images on a page.](https://stackoverflow.com/questions/31526085/how-to-encode-an-image-into-an-html-file)  Manually easier to get [QR-code as an image](/#getQRCode)    When you request the status of the instance in standby mode (status **\"init\"**), it will automatically turn on. To avoid this behavior, use the **no_wakeup** parameter
         * @summary Get the account status and QR code for authorization.
         * @param {boolean} [full] Get full information on the current status
         * @param {boolean} [noWakeup] Ignore autowakeup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(full?: boolean, noWakeup?: boolean, options?: any): AxiosPromise<InstanceStatus> {
            return localVarFp.getStatus(full, noWakeup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout from WhatsApp Web to get new QR code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot your whatsapp instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reboot(options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.reboot(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Repeat the manual synchronization attempt with the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retry(options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.retry(options).then((request) => request(axios, basePath));
        },
        /**
         * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
         * @summary Set settings
         * @param {Settings} settings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSettings(settings: Settings, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.setSettings(settings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the active session if the device has connected another instance of Web WhatsApp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeover(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.takeover(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1InstanceApi - object-oriented interface
 * @export
 * @class Class1InstanceApi
 * @extends {BaseAPI}
 */
export class Class1InstanceApi extends BaseAPI {
    /**
     * 
     * @summary Updates the QR code after its expired
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public expiry(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).expiry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Direct link to QR-code in the form of an image, not base64.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public getQRCode(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).getQRCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
     * @summary Get settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public getSettings(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reauthorization is necessary only in case of changing the device or manually pressing \"Logout on all devices\" on the phone. Keep the WhastsApp application open during authorization.  Instance statuses:  **authenticated** -  Authorization passed successfully  **init** -  Initial status   **loading** -  The system is still loading, try again in 1 minute   **got qr code** -  There is a QR code and you need to take a picture of it in the Whatsapp application by going to Menu -> WhatsApp Web -> Add. QR code is valid for one minute.   [Example showing base64 images on a page.](https://stackoverflow.com/questions/31526085/how-to-encode-an-image-into-an-html-file)  Manually easier to get [QR-code as an image](/#getQRCode)    When you request the status of the instance in standby mode (status **\"init\"**), it will automatically turn on. To avoid this behavior, use the **no_wakeup** parameter
     * @summary Get the account status and QR code for authorization.
     * @param {boolean} [full] Get full information on the current status
     * @param {boolean} [noWakeup] Ignore autowakeup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public getStatus(full?: boolean, noWakeup?: boolean, options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).getStatus(full, noWakeup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout from WhatsApp Web to get new QR code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public logout(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot your whatsapp instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public reboot(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).reboot(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Repeat the manual synchronization attempt with the device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public retry(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).retry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **webhookUrl** - Http or https URL for receiving notifications. For testing, we recommend using [our RequestBin](http://bin.chat-api.com).  **ackNotificationsOn** - Turn on/off ack (message delivered and message viewed) notifications in webhooks. GET method works for the same address.  **chatUpdateOn** - Turn on/off chat update notifications in webhooks. GET method works for the same address.  **videoUploadOn** - Turn on/off receiving video messages.  **proxy** - Socks5 IP address and port proxy for instance.  **guaranteedHooks** - Guarantee webhook delivery. Each webhook will make 20 attempts to send until it receives 200 status from the server.  **ignoreOldMessages** - Do not send webhooks with old messages during authorization.  **processArchive** - Process messages from archived chats.  **instanceStatuses** - Turn on/off collecting instance status changing history.  **webhookStatuses** - Turn on/off collecting messages webhooks statuses.  **statusNotificationsOn** - Turn on/off instance changind status notifications in webhooks.
     * @summary Set settings
     * @param {Settings} settings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public setSettings(settings: Settings, options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).setSettings(settings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the active session if the device has connected another instance of Web WhatsApp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1InstanceApi
     */
    public takeover(options?: AxiosRequestConfig) {
        return Class1InstanceApiFp(this.configuration).takeover(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class2MessagesApi - axios parameter creator
 * @export
 */
export const Class2MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Forwarding messages to a new or existing chat.
         * @param {ForwardMessageRequest} forwardMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardMessage: async (forwardMessageRequest: ForwardMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forwardMessageRequest' is not null or undefined
            assertParamExists('forwardMessage', 'forwardMessageRequest', forwardMessageRequest)
            const localVarPath = `/forwardMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
         * @summary Get a list of messages.
         * @param {number} [lastMessageNumber] The lastMessageNumber parameter from the last response
         * @param {boolean} [last] Displays the last 100 messages. If this parameter is passed, then lastMessageNumber is ignored.
         * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
         * @param {number} [limit] Sets length of the message list. Default 100. With value 0 returns all messages.
         * @param {number} [minTime] Filter messages received after specified time. Example: 946684800.
         * @param {number} [maxTime] Filter messages received before specified time. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (lastMessageNumber?: number, last?: boolean, chatId?: string, limit?: number, minTime?: number, maxTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (lastMessageNumber !== undefined) {
                localVarQueryParameter['lastMessageNumber'] = lastMessageNumber;
            }

            if (last !== undefined) {
                localVarQueryParameter['last'] = last;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minTime !== undefined) {
                localVarQueryParameter['min_time'] = minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['max_time'] = maxTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
         * @summary Get a list of messages.
         * @param {number} [page] page number
         * @param {number} [count] page items count.
         * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof Class2MessagesApi
         */
        getMessagesHistory: async (page?: number, count?: number, chatId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/messagesHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a contact or contact list to a new or existing chat.
         * @param {SendContactRequest} sendContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendContact: async (sendContactRequest: SendContactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendContactRequest' is not null or undefined
            assertParamExists('sendContact', 'sendContactRequest', sendContactRequest)
            const localVarPath = `/sendContact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendFileRequest} sendFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFile: async (sendFileRequest: SendFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendFileRequest' is not null or undefined
            assertParamExists('sendFile', 'sendFileRequest', sendFileRequest)
            const localVarPath = `/sendFile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send text with link and link\'s preview to a new or existing chat.
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink: async (sendLinkRequest: SendLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendLinkRequest' is not null or undefined
            assertParamExists('sendLink', 'sendLinkRequest', sendLinkRequest)
            const localVarPath = `/sendLink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a location to a new or existing chat.
         * @param {SendLocationRequest} sendLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLocation: async (sendLocationRequest: SendLocationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendLocationRequest' is not null or undefined
            assertParamExists('sendLocation', 'sendLocationRequest', sendLocationRequest)
            const localVarPath = `/sendLocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The message will be added to the queue for sending and delivered even if the phone is disconnected from the Internet or authorization is not passed.  Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a message to a new or existing chat.
         * @param {SendMessageRequest} sendMessageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageRequest: SendMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageRequest' is not null or undefined
            assertParamExists('sendMessage', 'sendMessageRequest', sendMessageRequest)
            const localVarPath = `/sendMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendProductRequest} sendProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendProduct: async (sendProductRequest: SendProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('sendProduct', 'sendProductRequest', sendProductRequest)
            const localVarPath = `/sendProduct`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a buttons to a new or existing chat.
         * @param {SendButtonsRequest} sendButtonsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendButtons: async (sendButtonsRequest: SendButtonsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('sendButtons', 'sendButtonsRequest', sendButtonsRequest)
            const localVarPath = `/sendButtons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendButtonsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The message will be deleted.
         * @summary Delete message from WhatsApp.
         * @param {DeleteMessageRequest} deleteMessageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (deleteMessageRequest: DeleteMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('deleteMessage', 'deleteMessageRequest', deleteMessageRequest)
            const localVarPath = `/deleteMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a ptt-audio to a new or existing chat.
         * @param {SendPTTRequest} sendPTTRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPTT: async (sendPTTRequest: SendPTTRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendPTTRequest' is not null or undefined
            assertParamExists('sendPTT', 'sendPTTRequest', sendPTTRequest)
            const localVarPath = `/sendPTT`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPTTRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a vcard to a new or existing chat.
         * @param {SendVCardRequest} sendVCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVCard: async (sendVCardRequest: SendVCardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendVCardRequest' is not null or undefined
            assertParamExists('sendVCard', 'sendVCardRequest', sendVCardRequest)
            const localVarPath = `/sendVCard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendVCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2MessagesApi - functional programming interface
 * @export
 */
export const Class2MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Forwarding messages to a new or existing chat.
         * @param {ForwardMessageRequest} forwardMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forwardMessage(forwardMessageRequest: ForwardMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardMessage(forwardMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
         * @summary Get a list of messages.
         * @param {number} [lastMessageNumber] The lastMessageNumber parameter from the last response
         * @param {boolean} [last] Displays the last 100 messages. If this parameter is passed, then lastMessageNumber is ignored.
         * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
         * @param {number} [limit] Sets length of the message list. Default 100. With value 0 returns all messages.
         * @param {number} [minTime] Filter messages received after specified time. Example: 946684800.
         * @param {number} [maxTime] Filter messages received before specified time. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(lastMessageNumber?: number, last?: boolean, chatId?: string, limit?: number, minTime?: number, maxTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Messages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessages(lastMessageNumber, last, chatId, limit, minTime, maxTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
         * @summary Get a list of messages.
         * @param {number} [page] page number
         * @param {number} [count] page items count.
         * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof Class2MessagesApi
        */
        async getMessagesHistory(page?: number, count?: number, chatId?: string, options?: AxiosRequestConfig) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesHistory(page, count, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a contact or contact list to a new or existing chat.
         * @param {SendContactRequest} sendContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendContact(sendContactRequest: SendContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendContact(sendContactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendFileRequest} sendFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFile(sendFileRequest: SendFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFile(sendFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send text with link and link\'s preview to a new or existing chat.
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLink(sendLinkRequest: SendLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLink(sendLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a location to a new or existing chat.
         * @param {SendLocationRequest} sendLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLocation(sendLocationRequest: SendLocationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLocation(sendLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The message will be added to the queue for sending and delivered even if the phone is disconnected from the Internet or authorization is not passed.  Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a message to a new or existing chat.
         * @param {SendMessageRequest} sendMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageRequest: SendMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendProductRequest} sendProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendProduct(sendProductRequest: SendProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendProduct(sendProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a buttons to a new or existing chat.
         * @param {SendButtonsRequest} sendButtonsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendButtons(sendButtonsRequest: SendButtonsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendButtons(sendButtonsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The message will be deleted.
         * @summary Delete message from WhatsApp.
         * @param {SendProductRequest} deleteMessageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(deleteMessageRequest: DeleteMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(deleteMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a ptt-audio to a new or existing chat.
         * @param {SendPTTRequest} sendPTTRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPTT(sendPTTRequest: SendPTTRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPTT(sendPTTRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a vcard to a new or existing chat.
         * @param {SendVCardRequest} sendVCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVCard(sendVCardRequest: SendVCardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMessageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVCard(sendVCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class2MessagesApi - factory interface
 * @export
 */
export const Class2MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2MessagesApiFp(configuration)
    return {
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Forwarding messages to a new or existing chat.
         * @param {ForwardMessageRequest} forwardMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardMessage(forwardMessageRequest: ForwardMessageRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.forwardMessage(forwardMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
         * @summary Get a list of messages.
         * @param {number} [lastMessageNumber] The lastMessageNumber parameter from the last response
         * @param {boolean} [last] Displays the last 100 messages. If this parameter is passed, then lastMessageNumber is ignored.
         * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
         * @param {number} [limit] Sets length of the message list. Default 100. With value 0 returns all messages.
         * @param {number} [minTime] Filter messages received after specified time. Example: 946684800.
         * @param {number} [maxTime] Filter messages received before specified time. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(lastMessageNumber?: number, last?: boolean, chatId?: string, limit?: number, minTime?: number, maxTime?: number, options?: any): AxiosPromise<Messages> {
            return localVarFp.getMessages(lastMessageNumber, last, chatId, limit, minTime, maxTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a contact or contact list to a new or existing chat.
         * @param {SendContactRequest} sendContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendContact(sendContactRequest: SendContactRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendContact(sendContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendFileRequest} sendFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFile(sendFileRequest: SendFileRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendFile(sendFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send text with link and link\'s preview to a new or existing chat.
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink(sendLinkRequest: SendLinkRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendLink(sendLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a location to a new or existing chat.
         * @param {SendLocationRequest} sendLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLocation(sendLocationRequest: SendLocationRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendLocation(sendLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The message will be added to the queue for sending and delivered even if the phone is disconnected from the Internet or authorization is not passed.  Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a message to a new or existing chat.
         * @param {SendMessageRequest} sendMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageRequest: SendMessageRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendMessage(sendMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a file to a new or existing chat.
         * @param {SendProductRequest} sendProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendProduct(sendProductRequest: SendProductRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendProduct(sendProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a buttons to a new or existing chat.
         * @param {SendButtonsRequest} sendButtonsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendButtons(sendButtonsRequest: SendButtonsRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendButtons(sendButtonsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The message will be deleted.
         * @summary Delete message from WhatsApp.
         * @param {DeleteMessageRequest} deleteMessageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(deleteMessageRequest: DeleteMessageRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.deleteMessage(deleteMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Send a ptt-audio to a new or existing chat.
         * @param {SendPTTRequest} sendPTTRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPTT(sendPTTRequest: SendPTTRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendPTT(sendPTTRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only one of two parameters is needed to determine the destination - chatId or phone.
         * @summary Sending a vcard to a new or existing chat.
         * @param {SendVCardRequest} sendVCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVCard(sendVCardRequest: SendVCardRequest, options?: any): AxiosPromise<SendMessageStatus> {
            return localVarFp.sendVCard(sendVCardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2MessagesApi - object-oriented interface
 * @export
 * @class Class2MessagesApi
 * @extends {BaseAPI}
 */
export class Class2MessagesApi extends BaseAPI {
    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Forwarding messages to a new or existing chat.
     * @param {ForwardMessageRequest} forwardMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public forwardMessage(forwardMessageRequest: ForwardMessageRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).forwardMessage(forwardMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
     * @summary Get a list of messages.
     * @param {number} [lastMessageNumber] The lastMessageNumber parameter from the last response
     * @param {boolean} [last] Displays the last 100 messages. If this parameter is passed, then lastMessageNumber is ignored.
     * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
     * @param {number} [limit] Sets length of the message list. Default 100. With value 0 returns all messages.
     * @param {number} [minTime] Filter messages received after specified time. Example: 946684800.
     * @param {number} [maxTime] Filter messages received before specified time. Example: 946684800.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public getMessages(lastMessageNumber?: number, last?: boolean, chatId?: string, limit?: number, minTime?: number, maxTime?: number, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).getMessages(lastMessageNumber, last, chatId, limit, minTime, maxTime, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.
     * @summary Get a list of messages.
     * @param {number} [page] page number
     * @param {number} [count] page items count.
     * @param {string} [chatId] Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public getMessagesHistory(page?: number, count?: number, chatId?: string, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).getMessagesHistory(page, count, chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Sending a contact or contact list to a new or existing chat.
     * @param {SendContactRequest} sendContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendContact(sendContactRequest: SendContactRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendContact(sendContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Send a file to a new or existing chat.
     * @param {SendFileRequest} sendFileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendFile(sendFileRequest: SendFileRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendFile(sendFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Send text with link and link\'s preview to a new or existing chat.
     * @param {SendLinkRequest} sendLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendLink(sendLinkRequest: SendLinkRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendLink(sendLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Sending a location to a new or existing chat.
     * @param {SendLocationRequest} sendLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendLocation(sendLocationRequest: SendLocationRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendLocation(sendLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The message will be added to the queue for sending and delivered even if the phone is disconnected from the Internet or authorization is not passed.  Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Send a message to a new or existing chat.
     * @param {SendMessageRequest} sendMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendMessage(sendMessageRequest: SendMessageRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendMessage(sendMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Send a file to a new or existing chat.
     * @param {SendProductRequest} sendProductRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendProduct(sendProductRequest: SendProductRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendProduct(sendProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Sending a buttons to a new or existing chat.
     * @param {SendButtonsRequest} sendButtonsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendButtons(sendButtonsRequest: SendButtonsRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendButtons(sendButtonsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The message will be deleted.
     * @summary Delete message from WhatsApp.
     * @param {DeleteMessageRequest} deleteMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public deleteMessage(deleteMessageRequest: DeleteMessageRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).deleteMessage(deleteMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Send a ptt-audio to a new or existing chat.
     * @param {SendPTTRequest} sendPTTRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendPTT(sendPTTRequest: SendPTTRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendPTT(sendPTTRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only one of two parameters is needed to determine the destination - chatId or phone.
     * @summary Sending a vcard to a new or existing chat.
     * @param {SendVCardRequest} sendVCardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2MessagesApi
     */
    public sendVCard(sendVCardRequest: SendVCardRequest, options?: AxiosRequestConfig) {
        return Class2MessagesApiFp(this.configuration).sendVCard(sendVCardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class3ChatsApi - axios parameter creator
 * @export
 */
export const Class3ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adding participant to a group
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupParticipant: async (groupParticipantAction: GroupParticipantAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupParticipantAction' is not null or undefined
            assertParamExists('addGroupParticipant', 'groupParticipantAction', groupParticipantAction)
            const localVarPath = `/addGroupParticipant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupParticipantAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Demote group participant
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demoteGroupParticipant: async (groupParticipantAction: GroupParticipantAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupParticipantAction' is not null or undefined
            assertParamExists('demoteGroupParticipant', 'groupParticipantAction', groupParticipantAction)
            const localVarPath = `/demoteGroupParticipant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupParticipantAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The chat list includes avatars.
         * @summary Get the chat list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dialogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The group will be added to the queue for sending and sooner or later it will be created, even if the phone is disconnected from the Internet or the authorization is not passed.   2 Oct 2018 update: chatId parameter will be returned if group was created on your phone within 20 second.
         * @summary Creates a group and sends the message to the created group.
         * @param {CreateGroupAction} createGroupAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        group: async (createGroupAction: CreateGroupAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupAction' is not null or undefined
            assertParamExists('group', 'createGroupAction', createGroupAction)
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Make participant in the group an administrator
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteGroupParticipant: async (groupParticipantAction: GroupParticipantAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupParticipantAction' is not null or undefined
            assertParamExists('promoteGroupParticipant', 'groupParticipantAction', groupParticipantAction)
            const localVarPath = `/promoteGroupParticipant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupParticipantAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to make users see their messages read.
         * @summary Open chat for reading messages
         * @param {ReadChatAction} readChatAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChat: async (readChatAction: ReadChatAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'readChatAction' is not null or undefined
            assertParamExists('readChat', 'readChatAction', readChatAction)
            const localVarPath = `/readChat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readChatAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove participant from a group
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupParticipant: async (groupParticipantAction: GroupParticipantAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupParticipantAction' is not null or undefined
            assertParamExists('removeGroupParticipant', 'groupParticipantAction', groupParticipantAction)
            const localVarPath = `/removeGroupParticipant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupParticipantAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3ChatsApi - functional programming interface
 * @export
 */
export const Class3ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adding participant to a group
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupParticipantStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupParticipant(groupParticipantAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Demote group participant
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupParticipantStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demoteGroupParticipant(groupParticipantAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The chat list includes avatars.
         * @summary Get the chat list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The group will be added to the queue for sending and sooner or later it will be created, even if the phone is disconnected from the Internet or the authorization is not passed.   2 Oct 2018 update: chatId parameter will be returned if group was created on your phone within 20 second.
         * @summary Creates a group and sends the message to the created group.
         * @param {CreateGroupAction} createGroupAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async group(createGroupAction: CreateGroupAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGroupStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.group(createGroupAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Make participant in the group an administrator
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupParticipantStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteGroupParticipant(groupParticipantAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to make users see their messages read.
         * @summary Open chat for reading messages
         * @param {ReadChatAction} readChatAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readChat(readChatAction: ReadChatAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadChatStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readChat(readChatAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove participant from a group
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupParticipantStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupParticipant(groupParticipantAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class3ChatsApi - factory interface
 * @export
 */
export const Class3ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3ChatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Adding participant to a group
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: any): AxiosPromise<GroupParticipantStatus> {
            return localVarFp.addGroupParticipant(groupParticipantAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Demote group participant
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: any): AxiosPromise<GroupParticipantStatus> {
            return localVarFp.demoteGroupParticipant(groupParticipantAction, options).then((request) => request(axios, basePath));
        },
        /**
         * The chat list includes avatars.
         * @summary Get the chat list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChats(options?: any): AxiosPromise<Chats> {
            return localVarFp.getChats(options).then((request) => request(axios, basePath));
        },
        /**
         * The group will be added to the queue for sending and sooner or later it will be created, even if the phone is disconnected from the Internet or the authorization is not passed.   2 Oct 2018 update: chatId parameter will be returned if group was created on your phone within 20 second.
         * @summary Creates a group and sends the message to the created group.
         * @param {CreateGroupAction} createGroupAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        group(createGroupAction: CreateGroupAction, options?: any): AxiosPromise<CreateGroupStatus> {
            return localVarFp.group(createGroupAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Make participant in the group an administrator
         * @param {GroupParticipantAction} groupParticipantAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: any): AxiosPromise<GroupParticipantStatus> {
            return localVarFp.promoteGroupParticipant(groupParticipantAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to make users see their messages read.
         * @summary Open chat for reading messages
         * @param {ReadChatAction} readChatAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChat(readChatAction: ReadChatAction, options?: any): AxiosPromise<ReadChatStatus> {
            return localVarFp.readChat(readChatAction, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove participant from a group
         * @param {GroupParticipantAction} groupParticipantAction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: any): AxiosPromise<GroupParticipantStatus> {
            return localVarFp.removeGroupParticipant(groupParticipantAction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3ChatsApi - object-oriented interface
 * @export
 * @class Class3ChatsApi
 * @extends {BaseAPI}
 */
export class Class3ChatsApi extends BaseAPI {
    /**
     *
     * @summary Adding participant to a group
     * @param {GroupParticipantAction} groupParticipantAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public addGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).addGroupParticipant(groupParticipantAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Demote group participant
     * @param {GroupParticipantAction} groupParticipantAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public demoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).demoteGroupParticipant(groupParticipantAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The chat list includes avatars.
     * @summary Get the chat list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public getChats(options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).getChats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The group will be added to the queue for sending and sooner or later it will be created, even if the phone is disconnected from the Internet or the authorization is not passed.   2 Oct 2018 update: chatId parameter will be returned if group was created on your phone within 20 second.
     * @summary Creates a group and sends the message to the created group.
     * @param {CreateGroupAction} createGroupAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public group(createGroupAction: CreateGroupAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).group(createGroupAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Make participant in the group an administrator
     * @param {GroupParticipantAction} groupParticipantAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public promoteGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).promoteGroupParticipant(groupParticipantAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to make users see their messages read.
     * @summary Open chat for reading messages
     * @param {ReadChatAction} readChatAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public readChat(readChatAction: ReadChatAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).readChat(readChatAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove participant from a group
     * @param {GroupParticipantAction} groupParticipantAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3ChatsApi
     */
    public removeGroupParticipant(groupParticipantAction: GroupParticipantAction, options?: AxiosRequestConfig) {
        return Class3ChatsApiFp(this.configuration).removeGroupParticipant(groupParticipantAction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class4WebhooksApi - axios parameter creator
 * @export
 */
export const Class4WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sets the URL for receiving webhook notifications of new messages and message delivery events (ack).  **API responses in \"Callbacks\" tab**
         * @summary Sets the URL for receiving webhook
         * @param {WebhookUrl} webhookUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebhook: async (webhookUrl: WebhookUrl, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookUrl' is not null or undefined
            assertParamExists('setWebhook', 'webhookUrl', webhookUrl)
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUrl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class4WebhooksApi - functional programming interface
 * @export
 */
export const Class4WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class4WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Sets the URL for receiving webhook notifications of new messages and message delivery events (ack).  **API responses in \"Callbacks\" tab**
         * @summary Sets the URL for receiving webhook
         * @param {WebhookUrl} webhookUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWebhook(webhookUrl: WebhookUrl, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetWebhookStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWebhook(webhookUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class4WebhooksApi - factory interface
 * @export
 */
export const Class4WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class4WebhooksApiFp(configuration)
    return {
        /**
         * Sets the URL for receiving webhook notifications of new messages and message delivery events (ack).  **API responses in \"Callbacks\" tab**
         * @summary Sets the URL for receiving webhook
         * @param {WebhookUrl} webhookUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebhook(webhookUrl: WebhookUrl, options?: any): AxiosPromise<SetWebhookStatus> {
            return localVarFp.setWebhook(webhookUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class4WebhooksApi - object-oriented interface
 * @export
 * @class Class4WebhooksApi
 * @extends {BaseAPI}
 */
export class Class4WebhooksApi extends BaseAPI {
    /**
     * Sets the URL for receiving webhook notifications of new messages and message delivery events (ack).  **API responses in \"Callbacks\" tab**
     * @summary Sets the URL for receiving webhook
     * @param {WebhookUrl} webhookUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class4WebhooksApi
     */
    public setWebhook(webhookUrl: WebhookUrl, options?: AxiosRequestConfig) {
        return Class4WebhooksApiFp(this.configuration).setWebhook(webhookUrl, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class5QueuesApi - axios parameter creator
 * @export
 */
export const Class5QueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is needed when you accidentally sent thousands of actions in a row.
         * @summary Clear outbound actions queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearActionsQueue: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clearActionsQueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is needed when you accidentally sent thousands of messages in a row.
         * @summary Clear outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMessagesQueue: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clearMessagesQueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When you create an action, all actions are queued up. If an action is not executed, it remains in the queue and will be sent for execution in time. again. The action cannot be executed due to the status of the device connected to the account.  This method give the last 100 actions in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showActionsQueue: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/showActionsQueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending messages, all messages are in the queue. If the message is not sent, then it remains in the queue and in time it will be sent again. The message may not be sent due to the status of the device connected to the account.   This method give the last 100 messages in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMessagesQueue: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/showMessagesQueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5QueuesApi - functional programming interface
 * @export
 */
export const Class5QueuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5QueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is needed when you accidentally sent thousands of actions in a row.
         * @summary Clear outbound actions queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearActionsQueue(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClearActionsQueueStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearActionsQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is needed when you accidentally sent thousands of messages in a row.
         * @summary Clear outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearMessagesQueue(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClearMessagesQueueStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearMessagesQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When you create an action, all actions are queued up. If an action is not executed, it remains in the queue and will be sent for execution in time. again. The action cannot be executed due to the status of the device connected to the account.  This method give the last 100 actions in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showActionsQueue(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundActions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showActionsQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When sending messages, all messages are in the queue. If the message is not sent, then it remains in the queue and in time it will be sent again. The message may not be sent due to the status of the device connected to the account.   This method give the last 100 messages in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showMessagesQueue(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundMessages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showMessagesQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class5QueuesApi - factory interface
 * @export
 */
export const Class5QueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5QueuesApiFp(configuration)
    return {
        /**
         * This method is needed when you accidentally sent thousands of actions in a row.
         * @summary Clear outbound actions queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearActionsQueue(options?: any): AxiosPromise<ClearActionsQueueStatus> {
            return localVarFp.clearActionsQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is needed when you accidentally sent thousands of messages in a row.
         * @summary Clear outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMessagesQueue(options?: any): AxiosPromise<ClearMessagesQueueStatus> {
            return localVarFp.clearMessagesQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * When you create an action, all actions are queued up. If an action is not executed, it remains in the queue and will be sent for execution in time. again. The action cannot be executed due to the status of the device connected to the account.  This method give the last 100 actions in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showActionsQueue(options?: any): AxiosPromise<OutboundActions> {
            return localVarFp.showActionsQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * When sending messages, all messages are in the queue. If the message is not sent, then it remains in the queue and in time it will be sent again. The message may not be sent due to the status of the device connected to the account.   This method give the last 100 messages in the queue.
         * @summary Get outbound messages queue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMessagesQueue(options?: any): AxiosPromise<OutboundMessages> {
            return localVarFp.showMessagesQueue(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5QueuesApi - object-oriented interface
 * @export
 * @class Class5QueuesApi
 * @extends {BaseAPI}
 */
export class Class5QueuesApi extends BaseAPI {
    /**
     * This method is needed when you accidentally sent thousands of actions in a row.
     * @summary Clear outbound actions queue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5QueuesApi
     */
    public clearActionsQueue(options?: AxiosRequestConfig) {
        return Class5QueuesApiFp(this.configuration).clearActionsQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is needed when you accidentally sent thousands of messages in a row.
     * @summary Clear outbound messages queue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5QueuesApi
     */
    public clearMessagesQueue(options?: AxiosRequestConfig) {
        return Class5QueuesApiFp(this.configuration).clearMessagesQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When you create an action, all actions are queued up. If an action is not executed, it remains in the queue and will be sent for execution in time. again. The action cannot be executed due to the status of the device connected to the account.  This method give the last 100 actions in the queue.
     * @summary Get outbound messages queue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5QueuesApi
     */
    public showActionsQueue(options?: AxiosRequestConfig) {
        return Class5QueuesApiFp(this.configuration).showActionsQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When sending messages, all messages are in the queue. If the message is not sent, then it remains in the queue and in time it will be sent again. The message may not be sent due to the status of the device connected to the account.   This method give the last 100 messages in the queue.
     * @summary Get outbound messages queue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5QueuesApi
     */
    public showMessagesQueue(options?: AxiosRequestConfig) {
        return Class5QueuesApiFp(this.configuration).showMessagesQueue(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class6BanApi - axios parameter creator
 * @export
 */
export const Class6BanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send the phone number to find out if the instance is banning it
         * @summary Test ban settings
         * @param {BanTestAction} banTestAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banTest: async (banTestAction: BanTestAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'banTestAction' is not null or undefined
            assertParamExists('banTest', 'banTestAction', banTestAction)
            const localVarPath = `/banTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banTestAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Set settings
         * @param {BanSettings} banSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBanSettings: async (banSettings: BanSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'banSettings' is not null or undefined
            assertParamExists('setBanSettings', 'banSettings', banSettings)
            const localVarPath = `/banSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class6BanApi - functional programming interface
 * @export
 */
export const Class6BanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class6BanApiAxiosParamCreator(configuration)
    return {
        /**
         * Send the phone number to find out if the instance is banning it
         * @summary Test ban settings
         * @param {BanTestAction} banTestAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banTest(banTestAction: BanTestAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanTestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banTest(banTestAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Set settings
         * @param {BanSettings} banSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBanSettings(banSettings: BanSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBanSettings(banSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class6BanApi - factory interface
 * @export
 */
export const Class6BanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class6BanApiFp(configuration)
    return {
        /**
         * Send the phone number to find out if the instance is banning it
         * @summary Test ban settings
         * @param {BanTestAction} banTestAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banTest(banTestAction: BanTestAction, options?: any): AxiosPromise<BanTestStatus> {
            return localVarFp.banTest(banTestAction, options).then((request) => request(axios, basePath));
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanSettings(options?: any): AxiosPromise<BanSettings> {
            return localVarFp.getBanSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
         * @summary Set settings
         * @param {BanSettings} banSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBanSettings(banSettings: BanSettings, options?: any): AxiosPromise<BanSettings> {
            return localVarFp.setBanSettings(banSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class6BanApi - object-oriented interface
 * @export
 * @class Class6BanApi
 * @extends {BaseAPI}
 */
export class Class6BanApi extends BaseAPI {
    /**
     * Send the phone number to find out if the instance is banning it
     * @summary Test ban settings
     * @param {BanTestAction} banTestAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class6BanApi
     */
    public banTest(banTestAction: BanTestAction, options?: AxiosRequestConfig) {
        return Class6BanApiFp(this.configuration).banTest(banTestAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
     * @summary Get settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class6BanApi
     */
    public getBanSettings(options?: AxiosRequestConfig) {
        return Class6BanApiFp(this.configuration).getBanSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **banPhoneMask** - Regular expression on which bans on numbers will be sent  **preBanMessage** - Warning message If it is set, a message will be sent before sending the ban.
     * @summary Set settings
     * @param {BanSettings} banSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class6BanApi
     */
    public setBanSettings(banSettings: BanSettings, options?: AxiosRequestConfig) {
        return Class6BanApiFp(this.configuration).setBanSettings(banSettings, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class7TestingApi - axios parameter creator
 * @export
 */
export const Class7TestingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires enable \"instanceStatuses\" option for collecting data.
         * @summary Returns instance status changes history.
         * @param {number} [minTime] Filter statuses received after specified date. Example: 946684800.
         * @param {number} [maxTime] Filter statuses received before specified date. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instanceStatuses: async (minTime?: number, maxTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instanceStatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (minTime !== undefined) {
                localVarQueryParameter['min_time'] = minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['max_time'] = maxTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires enable \"webhookStatuses\" option for collecting data.
         * @summary Returns webhook status for message.
         * @param {string} msgId Message ID. Example: false_17472822486@c.us_DF38E6A25B42CC8CCE57EC40F.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookStatuses: async (msgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'msgId' is not null or undefined
            assertParamExists('webhookStatuses', 'msgId', msgId)
            const localVarPath = `/webhookStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication instanceId required
            await setApiKeyToObject(localVarQueryParameter, "instanceId", configuration)

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (msgId !== undefined) {
                localVarQueryParameter['msgId'] = msgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class7TestingApi - functional programming interface
 * @export
 */
export const Class7TestingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class7TestingApiAxiosParamCreator(configuration)
    return {
        /**
         * Requires enable \"instanceStatuses\" option for collecting data.
         * @summary Returns instance status changes history.
         * @param {number} [minTime] Filter statuses received after specified date. Example: 946684800.
         * @param {number} [maxTime] Filter statuses received before specified date. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instanceStatuses(minTime?: number, maxTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instanceStatuses(minTime, maxTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requires enable \"webhookStatuses\" option for collecting data.
         * @summary Returns webhook status for message.
         * @param {string} msgId Message ID. Example: false_17472822486@c.us_DF38E6A25B42CC8CCE57EC40F.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookStatuses(msgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookStatuses(msgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class7TestingApi - factory interface
 * @export
 */
export const Class7TestingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class7TestingApiFp(configuration)
    return {
        /**
         * Requires enable \"instanceStatuses\" option for collecting data.
         * @summary Returns instance status changes history.
         * @param {number} [minTime] Filter statuses received after specified date. Example: 946684800.
         * @param {number} [maxTime] Filter statuses received before specified date. Example: 946684800.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instanceStatuses(minTime?: number, maxTime?: number, options?: any): AxiosPromise<Statuses> {
            return localVarFp.instanceStatuses(minTime, maxTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires enable \"webhookStatuses\" option for collecting data.
         * @summary Returns webhook status for message.
         * @param {string} msgId Message ID. Example: false_17472822486@c.us_DF38E6A25B42CC8CCE57EC40F.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookStatuses(msgId: string, options?: any): AxiosPromise<WebhookStatus> {
            return localVarFp.webhookStatuses(msgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class7TestingApi - object-oriented interface
 * @export
 * @class Class7TestingApi
 * @extends {BaseAPI}
 */
export class Class7TestingApi extends BaseAPI {
    /**
     * Requires enable \"instanceStatuses\" option for collecting data.
     * @summary Returns instance status changes history.
     * @param {number} [minTime] Filter statuses received after specified date. Example: 946684800.
     * @param {number} [maxTime] Filter statuses received before specified date. Example: 946684800.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class7TestingApi
     */
    public instanceStatuses(minTime?: number, maxTime?: number, options?: AxiosRequestConfig) {
        return Class7TestingApiFp(this.configuration).instanceStatuses(minTime, maxTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires enable \"webhookStatuses\" option for collecting data.
     * @summary Returns webhook status for message.
     * @param {string} msgId Message ID. Example: false_17472822486@c.us_DF38E6A25B42CC8CCE57EC40F.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class7TestingApi
     */
    public webhookStatuses(msgId: string, options?: AxiosRequestConfig) {
        return Class7TestingApiFp(this.configuration).webhookStatuses(msgId, options).then((request) => request(this.axios, this.basePath));
    }
}


